# MSA를 이해하기 위해 대용량 트래픽과 동시성 제어 탐구

#### 배경

> **2022년 이후 MSA 아키텍처의 변화 양상이 커지고 있다.** 차세대 프로젝트 붐이 일어난 이후, 또 한번의 대규모 트래픽에 대응하기 위해 무거운 `모놀리식 서버` 안에 `마이크로 서버`로 분리를 할 수 있는 서비스를 분리하기 시작했다.</br>

> **대용량 트래픽에서 발생하는 동시성 문제는 경험 해보았다.** 차세데 프로젝트에서 등록 서비스를 구현 할 때, Key값을 가져오기 위해 `MyBatis`의 <selectKey>를 이용했었다. 아무런 제어도 없는 상태에서는 무결성 에러에 번번히 애를 먹고 지향하기로 했었다. (`auto increment`나 `Key generation 로직`을 따로 빼는걸 추천 ) </br>

> **비즈니스 계층에서 나는 어떻게 대용량 트래픽을 최대한 대응할 수 있을까?** 대용량 트래픽에 대응하기 위해 Spring Cloud의 로드밸런서, Redis의 캐시 기능등이 있는데 주니어 개발자는 아키텍처를 직접 고안하는 경험이 없으니 있는 자리에서 최대한 생각해보자. </br>

#### 목표

> 다중 트랜잭셕에서 발생하는 동시성을 먼저 이해하고, 해결방안을 최대한 생각해보자</br>
> DAO 계층에 쓰는 경우가 JPA 혹은 MyBatis 일때로 경우의 수를 나누어 생각해보자</br>
> Redis를 집중 학습하여 뭔가 해내자

---

## 목차

1. [분석](#-분석)

---

## ▶ 분석

1. **동시성 제어 이해**

   동시성 제어란?

   동시에 실행되는 여러 개의 트랜잭션이 작업을 성공적으로 마칠 수 있도록 트랜잭셕의 실행 순서를 제어하는 기법`

   ```mermaid
   graph LR
   A[트랜잭션 1] --> B[동시성 제어]
   A2[트랜잭션 2] --> B
   A3[트랜잭션 3] --> B

   subgraph 직렬화 수행
       direction LR
       B --> C[트랜잭션 3]
       C --> D[트랜잭션 2]
       D --> E[트랜잭션 1]
   end

   E --> F[DataBase]

   style B fill:#f9f9f9,stroke:#333,stroke-width:2px
   style C fill:#d9e8f6
   style D fill:#d9e8f6
   style E fill:#d9e8f6
   style F fill:#f8c6a0
   ```

비즈니스에서 동시성 제어는 **데이터의 무결성 및 일관성을 보장**가 가장 중요하다. </br>

    동시성 제어 기법 종류?

    1. 락킹 : 트랜잭션이 데이터에 잠금 lock을 설정하면 다른 트랜잭션은 해당 데이터에 대해 접근이 불가/ unlock시에는 접근/수정/삭제가 가능
    2. 타임스탬프 : 생성하는 고유 번호임 타임스탬프을 트랜잭션에 부여함으로 트랜잭션간의 접근 순서를 미리 정할 수 있다.
    3. 적합성 검증 : 먼저 트랜잭션을 수행하고 트랜잭션을 종료 할때 적합성을 검증하여 db 최종 반영

이론적으로 3가지가 존재하며 이를 코딩을 어떻게 실현 할 수 있을까?

2. **동시성 제어 실현**

   1. **@Transactional isolation 활용**
        <details>
          <summary> @Transactional 이란? </summary>
           
          스프링에서 트랜잭션 처리를 위해 선언적으로 트랜잭션에 행위를 정의하게 해주는 프록시 객체라고 생각하면된다.
        
          동작 원리가 결구 AOP를 통해 구현되어 있기 때문에 내가 만든 로직이 @Transactional을 붙여주면,
          [ 트랜잭션 시작 - 내가 만든 로직 - 트랜잭션 종료 ] 으로 실행하게 된다.
        
          클래스, 메소드, 인터페이스 메소드 단위로 정의할 수 있으며
        
          [클래스 메소드-> 클래스 -> 인터페이스 메소드 -> 인터페이스] 우선순위가 존재한다.
        
          Spring에서는 클래스에 적용하는 것을 권고한다. 자바 어노테이션은 인터페이스로부터 상속되지 않기 때문에 클래스 기반 프록시에서 트랜잭션 설정을 인식할 수 없다.

        </details>

      @Transactional 의 설정 중 isolation 이 있다.
      isolation은 일련의 트랜잭셕을 작업 중 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 격리 시키는 것이다.

      isolation에는 한 트랜잭션이 조회, 변경중인 데이터에 대한 접근의 혀용 수준을 결정하는 격리 수준이 존재한다.

      1. Read-Uncommited (level 1) : 다른 Transaction에서 변경이 **커밋되지 않았더라도 변경된 데이터를 조회할 수 있다.**

      2. Read-commited (level 2) : 커밋된 내용만 반영된 데이터에 대해서만 조회할 수 있는 격리 수준이다.
         트랜잭션 도중 다른 트랜잭션에서 **변경이 커밋되었다면 변경된 데이터를 조회할 수 있다.** (Oracle DBMS 기본 수준, 온라에서는 많이 사용됨)

      3. Repatable-Read (level 3) : 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준이다. 트랜잭션 내에서 조회하는 데이터에 대해 공유락을 걸어 잠금된 데이터의 변경 불가능이 보장된다. **리소스의 WRITE 제한을 건다.** (MySQL DBMS 기본 수준)

         - 모든 InnoDB의 트랜잭션은 순차적으로 증가하는 트랜잭션 번호를 가지고 있다. 해당 격리수준은 자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서는 변경된(커밋된) 것만 보게 되는 것이다.

      4. Serializable (level 4) :
