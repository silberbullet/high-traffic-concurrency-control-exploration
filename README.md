# MSA를 이해하기 위해 대용량 트래픽과 동시성 제어 탐구

#### 배경

> **2022년 이후 MSA 아키텍처의 변화 양상이 커지고 있다.** 차세대 프로젝트 붐이 일어난 이후, 또 한번의 대규모 트래픽에 대응하기 위해 무거운 `모놀리식 서버` 안에 `마이크로 서버`로 분리를 할 수 있는 서비스를 분리하기 시작했다.</br>

> **대용량 트래픽에서 발생하는 동시성 문제는 경험 해보았다.** 차세데 프로젝트에서 등록 서비스를 구현 할 때, Key값을 가져오기 위해 `MyBatis`의 <selectKey>를 이용했었다. 아무런 제어도 없는 상태에서는 무결성 에러에 번번히 애를 먹고 지향하기로 했었다. (`auto increment`나 `Key generation 로직`을 따로 빼는걸 추천 ) </br>

> **비즈니스 계층에서 나는 어떻게 대용량 트래픽을 최대한 대응할 수 있을까?** 대용량 트래픽에 대응하기 위해 Spring Cloud의 로드밸런서, Redis의 캐시 기능등이 있는데 주니어 개발자는 아키텍처를 직접 고안하는 경험이 없으니 있는 자리에서 최대한 생각해보자. </br>

#### 목표

> 다중 트랜잭셕에서 발생하는 동시성을 먼저 이해하고, 해결방안을 최대한 생각해보자
> DAO 계층에 쓰는 경우가 JPA 혹은 MyBatis 일때로 경우의 수를 나누어 생각해보자
> Redis를 집중 학습하여 뭔가 해내자

---

## 목차

1. [분석](#-분석)

---

## ▶ 분석

1. **동시성 제어 이해**

   동시성 제어란?

   동시에 실행되는 여러 개의 트랜잭션이 작업을 성공적으로 마칠 수 있도록 트랜잭셕의 실행 순서를 제어하는 기법`

   ```mermaid
   graph LR
   A[트랜잭션 1] --> B[동시성 제어]
   A2[트랜잭션 2] --> B
   A3[트랜잭션 3] --> B

   subgraph 직렬화 수행
       direction LR
       B --> C[트랜잭션 3]
       C --> D[트랜잭션 2]
       D --> E[트랜잭션 1]
   end

   E --> F[DataBase]

   style B fill:#f9f9f9,stroke:#333,stroke-width:2px
   style C fill:#d9e8f6
   style D fill:#d9e8f6
   style E fill:#d9e8f6
   style F fill:#f8c6a0
   ```

비즈니스에서 동시성 제어는 **데이터의 무결성 및 일관성을 보장**가 가장 중요하다. </br>

    동시성 제어 기법 종류?

    1. 락킹 : 트랜잭션이 데이터에 잠금 lock을 설정하면 다른 트랜잭션은 해당 데이터에 대해 접근이 불가/ unlock시에는 접근/수정/삭제가 가능
    2. 타임스탬프 : 생성하는 고유 번호임 타임스탬프을 트랜잭션에 부여함으로 트랜잭션간의 접근 순서를 미리 정할 수 있다.
    3. 적합성 검증 : 먼저 트랜잭션을 수행하고 트랜잭션을 종료 할때 적합성을 검증하여 db 최종 반영

이론적으로 3가지가 존재하며 이를 코딩을 어떻게 실현 할 수 있을까?

2. **동시성 제어 실현**

   1. **@Transactional 어노테이션**

      @Transactional 이란?

      스프링에서 트랜잭션 처리를 위해 선언적으로 트랜잭션에 행위를 정의하게 해주는 프록시 객체라고 생각하면된다.

      동작 원리가 결구 AOP를 통해 구현되어 있기 때문에 내가 만든 로직이 @Transactional을 붙여주면,
      [ 트랜잭션 시작 - 내가 만든 로직 - 트랜잭션 종료 ] 으로 실행하게 된다.

      클래스,메소드,인터페이스 메소드 단위로 정의할 수 있으며, 우선순위가 존재한다.

      **[클래스 메소드-> 클래스 -> 인터페이스 메소드 -> 인터페이스]**

      Spring에서는 클래스에 적용하는 것을 권고한다. **자바 어노테이션은 인터페이스로부터 상속되지 않기 때문에** 클래스 기반 프록시에서 트랜잭션 설정을 인식할 수 없다.
